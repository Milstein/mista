/* Generated By:JavaCC: Do not edit this line. MIDParser.java */
package parser;

import java.util.*;
import java.io.*;

import locales.LocaleBundle;
import mid.*;

// A variable name can be 
// 			either an identifier (IDENTIFIER) starting with a lower case letter 
// 			or a special name (SPECIALVAR) that starts with ? 
// use MID.isVariable(name) to check whether a name is legal
//
// Transition parameters must be variables
// Initial state, goal state, unit tests, and object mapping should not contain variables   

// for strings of precondition/postcondition/inscription/effect/unit tests
// where predicate arguments could be symbols, identifiers, special variables and strings
// constraints of unit tests need to be checked after parsing

public class MIDParser implements MIDParserConstants {

        // constructors are generated

        public static ArrayList<Predicate> parseConditionString(String inString) throws ParseException {
                if (inString.equals(""))
                        return new ArrayList<Predicate>();
                Reader reader = null;
                ArrayList<Predicate> condition = null;
                try {
                        reader = new StringReader(inString) ;
                        MIDParser parser = new MIDParser(reader) ;
                        condition = parser.parseConditionStream();
            }
            catch (ParseException e) {
                throw new ParseException(inString+": "+exceptionMessage(e));
            }
                catch (TokenMgrError e){
                                throw new ParseException(inString+": "+exceptionMessage(e));
                }
                finally {
                        try {reader.close();    }
                        catch (IOException ioe) {}
                }
                return condition;
        }

        public static String parseExpression(String inString) throws ParseException {
                Reader reader = null;
                try {
                        reader = new StringReader(inString) ;
                        ExpressionParser parser = new ExpressionParser(reader) ;
                        return parser.ArithmeticExpression();
            }
            catch (ParseException e) {
                throw e;
            }
                catch (TokenMgrError e){
                throw e;
                }
                finally {
                        try {reader.close();    }
                        catch (IOException ioe) {}
                }
        }

        public static ArrayList<String> collectExpressionVariables(String inString) throws ParseException {
                Reader reader = null;
                try {
                        reader = new StringReader(inString) ;
                        ExpressionParser parser = new ExpressionParser(reader) ;
                        return parser.collectExpressionVariables();
            }
            catch (ParseException e) {
                throw e;
            }
                catch (TokenMgrError e){
                throw e;
                }
                finally {
                        try {reader.close();    }
                        catch (IOException ioe) {}
                }
        }

        public static String evaluateExpression(String inString, Hashtable <String, String> bindings) throws ParseException {
                Reader reader = null;
                try {
                        reader = new StringReader(inString) ;
                        MIDParser parser = new MIDParser(reader) ;
                        return parser.evaluateExpressionValue(bindings);
            }
            catch (ParseException e) {
                throw e;
            }
                catch (TokenMgrError e){
                throw e;
                }
                finally {
                        try {reader.close();    }
                        catch (IOException ioe) {}
                }
        }

        // for strings of transition signatures where arguments are required to be variables
        public static Predicate parseTransitionSignatureString(String inString) throws ParseException {
                Reader reader = null;
                Predicate predicate = null;
                try {
                        reader = new StringReader(inString) ;
                        MIDParser parser = new MIDParser(reader) ;
                        predicate = parser.parseTransitionSignatureStream();
            }
            catch (ParseException e) {
                throw new ParseException(inString+" : "+LocaleBundle.bundleString("Incorrect transition signature"));
            }
                catch (TokenMgrError e){
                        throw new ParseException(inString+" : "+LocaleBundle.bundleString("Incorrect transition signature"));
                }
                finally {
                        try {reader.close();    }
                        catch (IOException ioe) {}
                }
                return predicate;
        }

        public static void parseWhenCondition(Transition transition, String whenConditionString) throws ParseException{
                ArrayList<Predicate> whenPredicates = parseConditionString(whenConditionString);
                for (Predicate predicate: whenPredicates)
                        if (!Functions.isFunction(predicate))
                                throw new ParseException(predicate+": "+LocaleBundle.bundleString("Incorrect function"));
                        else if (!Functions.hasCorrectArguments(predicate))
                                throw new ParseException(predicate+": "+LocaleBundle.bundleString("Incorrect argument"));
                transition.setWhenCondition(whenPredicates);
        }

        private static boolean containVariable(ArrayList<String> arguments, String variable){
                for (String argument: arguments)
                        if (argument.equals(variable))
                                return true;
                return false;
        }

        public static void checkTransitionArguments(String signatureString, ArrayList<String> transitionArguments,
                                ArrayList<Predicate> precondition, ArrayList<Predicate> whencondition) throws ParseException {
                if (transitionArguments!=null){
                        ArrayList<String> variableList = new ArrayList<String>();
                        for (Predicate predicate: precondition){
                                for (String argument: predicate.getArguments())
                                        if (MID.isVariable(argument) && !containVariable(variableList, argument))
                                                variableList.add(argument);
                        }
                        if (whencondition!=null){
                                for (Predicate predicate: whencondition){
                                        if (Functions.isArithmeticFunction(predicate)) {
                                                ArrayList<String> arguments = predicate.getArguments();
                                                variableList.add(arguments.get(arguments.size()-1));
                                        } else
                                        if (Functions.isEqualFunction(predicate)) {
                                                String arg1 = predicate.getArguments().get(0);
                                                if (MID.isVariable(arg1) && !containVariable(variableList, arg1))
                                                        variableList.add(arg1);
                                        }
                                }
                        }
                        for (String transitionArgument: transitionArguments) {
                                if (MID.isVariable(transitionArgument) && !containVariable(variableList, transitionArgument)){
                                        throw new ParseException(signatureString+": "+LocaleBundle.bundleString("Variable")
                                                + " " + transitionArgument +" "
                                                + LocaleBundle.bundleString("is undefined")
                                                + LocaleBundle.bundleString("It should appear in precondition"));
                                }
                        }
                }
        }

        public static void checkWhenConditionVariables(ArrayList<Predicate> precondition, ArrayList<Predicate> whencondition) throws ParseException {
                ArrayList<String> allVariables = new ArrayList<String>();
                for (Predicate predicate: precondition){
                                for (String argument: predicate.getArguments())
                                        if (MID.isVariable(argument) && !containVariable(allVariables, argument))
                                                allVariables.add(argument);
                }
                if (whencondition!=null){
                        for (Predicate whenPredicate: whencondition){
                                if (Functions.isArithmeticFunction(whenPredicate)) {
                                        ArrayList<String> arguments = whenPredicate.getArguments();
                                        for (int i=0; i<arguments.size()-1; i++)
                                                if (MID.isVariable(arguments.get(i)) && !containVariable(allVariables, arguments.get(i)))
                                                                throw new ParseException(LocaleBundle.bundleString("Variable")
                                                                                + " " + arguments.get(i) +" in "+ whenPredicate+" "
                                                                                + LocaleBundle.bundleString("is undefined")
                                                                                + LocaleBundle.bundleString("It should appear in precondition"));
                                        allVariables.add(arguments.get(arguments.size()-1));
                                } else
                                if (Functions.isEqualFunction(whenPredicate)){
                                        String arg1 = whenPredicate.getArguments().get(0);
                                        if (MID.isVariable(arg1) && !containVariable(allVariables, arg1))
                                                allVariables.add(arg1);
/*
System.out.println("Variables: ");						
for (String var: allVariables)
System.out.println(var);						
*/
                                        String arg2 = whenPredicate.getArguments().get(1);
                                        for (String var: collectExpressionVariables(arg2))
                                                if (!containVariable(allVariables, var))
                                                        throw new ParseException(LocaleBundle.bundleString("Variable")
                                                                                + " " + var +" in " + whenPredicate+" "
                                                                                + LocaleBundle.bundleString("is undefined")
                                                                                + LocaleBundle.bundleString("It should appear in precondition"));
                                } else
                                if (Functions.isComparisonFunction(whenPredicate)){
                                        String arg1 = whenPredicate.getArguments().get(0);
                                        if (MID.isVariable(arg1) && !containVariable(allVariables, arg1))
                                                throw new ParseException(LocaleBundle.bundleString("Variable")
                                                                                + " " + arg1 +" in " + whenPredicate+" "
                                                                                + LocaleBundle.bundleString("is undefined")
                                                                                + LocaleBundle.bundleString("It should appear in precondition"));
                                        String arg2 = whenPredicate.getArguments().get(1);
                                        for (String var: collectExpressionVariables(arg2))
                                                if (!containVariable(allVariables, var))
                                                        throw new ParseException(LocaleBundle.bundleString("Variable")
                                                                                + " " + var +" in " + whenPredicate+" "
                                                                                + LocaleBundle.bundleString("is undefined")
                                                                                + LocaleBundle.bundleString("It should appear in precondition"));
                                }
                        }
                }

        }

        public static void checkPostconditionVariables(Transition transition) throws ParseException {
                ArrayList<String> allVariables = new ArrayList<String>();
                // collect variables from precondition
                if (transition.getAllVariables()!=null){
                        for (String variable: transition.getAllVariables())
                                allVariables.add(variable);
                }
                // collect variables from when condition due to calculations
                if (transition.getWhenCondition()!=null){
                        for (Predicate whenPredicate: transition.getWhenCondition()){
                                if (Functions.isArithmeticFunction(whenPredicate)) {
                                        ArrayList<String> arguments = whenPredicate.getArguments();
                                        allVariables.add(arguments.get(arguments.size()-1));
                                } else
                                if (Functions.isEqualFunction(whenPredicate)) {
                                        String arg1 = whenPredicate.getArguments().get(0);
                                        if (MID.isVariable(arg1) && !containVariable(allVariables, arg1))
                                                allVariables.add(arg1);
                                }
                        }
                }
                // each postcondition variable must have occured in precondition or when condition
                if (transition.getPostcondition()!=null){
                        for (Predicate postPredicate: transition.getPostcondition()){
                                if (!postPredicate.getName().equalsIgnoreCase(MID.RESET)){
                                        for (String argument: postPredicate.getArguments())
                                                if (MID.isVariable(argument) && !containVariable(allVariables, argument))
                                                        throw new ParseException(postPredicate+": "+ argument +" "+LocaleBundle.bundleString("is undefined"+"\u005cn")
                                                        + LocaleBundle.bundleString("VARIABLES_IN_POSTCONDITIONS_SHOULD_APPEAR_IN_PRECONDIITONS"));
                                }
                        }
                }
        }

        // For  PrT net strings 
        public static Transition parseNetTransition(String signatureString,
                        String precondString, String postcondString,
                        String inscriptionString, String effectString, String guard) throws ParseException {
                return parseNetTransition(false, signatureString, precondString, postcondString, inscriptionString, effectString, guard);
        }

        public static Transition parseNetTransition(boolean isContractsSpec, String signatureString,
                        String precondString, String postcondString, String inscriptionString,
                        String effectString, String guard) throws ParseException {
                Predicate transitionSignature = parseTransitionSignatureString(signatureString);
                Transition transition = new Transition(transitionSignature.getName());
                transition.setArguments(transitionSignature.getArguments());
//System.out.println("Parse transition");		
//System.out.println(signatureString);		
//System.out.println(precondString);		

                ArrayList<Predicate> precondition = parseConditionString(precondString);
                transition.setPrecondition(precondition);
//System.out.println(postcondString);		

                ArrayList<Predicate> postcondition = parseConditionString(postcondString);
                transition.setPostcondition(postcondition);
//System.out.println(inscriptionString);		

                if (inscriptionString!=null && !inscriptionString.equals("")) {
                        parseWhenCondition(transition, inscriptionString);
                }
//System.out.println(guard);		
//System.out.println(effectString);		

                ArrayList<Predicate> effect = parseConditionString(effectString);
                transition.setEffect(effect);

                if (guard!=null)
                        transition.setGuard(guard);

                checkTransitionArguments(signatureString, transitionSignature.getArguments(), precondition, transition.getWhenCondition());
                checkWhenConditionVariables(precondition, transition.getWhenCondition());

                if (isContractsSpec)
                        transition.transformFromContract();

                if (transition.preconditionContainsFunction())
                                throw new ParseException(LocaleBundle.bundleString("precondition contains function"));
                if (transition.postconditionContainsFunction())
                                throw new ParseException(LocaleBundle.bundleString("postcondition contains function"));

                transition.collectAllVariables();
                checkPostconditionVariables(transition);

                return transition;
        }

        // for contract strings
        public static Transition parseContractTransition(String signatureString,
                        String precondString, String postcondString,
                        String inscription, String effectString) throws ParseException {
                Transition transition = parseNetTransition(true, signatureString, precondString, postcondString, inscription, effectString, "");
                return transition;
        }

        // for transitions of state machines 
        public static Transition parseStateMachineTransition(String start, String end, String event,
                         String precondition, String postconditionString) throws ParseException {
                if (!isIdentifier(start))
                throw new ParseException(start+": "+LocaleBundle.bundleString("should start with a letter"));
                if (!isIdentifier(end))
                throw new ParseException(end+": "+LocaleBundle.bundleString("should start with a letter"));
                if (!isIdentifier(event))
                throw new ParseException(event+": "+LocaleBundle.bundleString("should start with a letter"));
                ArrayList<Predicate> postcondition = parseConditionString(postconditionString);
                return convertStateMachineTransitionToNetTransition(start, end, event, precondition, postcondition);
        }

        // for strings of initial and goal markings  
        public static Marking parseMarkingString(String inString) throws ParseException {
                Reader reader = null;
                Marking marking = null;
                try {
                        reader = new StringReader(inString) ;
                        MIDParser parser = new MIDParser(reader) ;
                        marking = parser.parseMarkingStream();
            }
            catch (ParseException e) {
                throw new ParseException(LocaleBundle.bundleString("incorrect marking")+"\u005cn"+exceptionMessage(e));
            }
                catch (TokenMgrError e){
                throw new ParseException(LocaleBundle.bundleString("incorrect marking")+"\u005cn"+exceptionMessage(e));
                }
                finally {
                        try {reader.close();    }
                        catch (IOException ioe) {}
                }
                return marking;
        }

        // for strings of goal markings  
        public static GoalProperty parseGoalPropertyString(String inString) throws ParseException {
                Reader reader = null;
                GoalProperty propertyTransition = null;
                try {
                        reader = new StringReader(inString) ;
                        MIDParser parser = new MIDParser(reader) ;
                        propertyTransition = parser.parseGoalPropertyStream(inString);
            }
            catch (ParseException e) {
                throw new ParseException(LocaleBundle.bundleString("incorrect marking")+"\u005cn"+exceptionMessage(e));
            }
                catch (TokenMgrError e){
                throw new ParseException(LocaleBundle.bundleString("incorrect marking")+"\u005cn"+exceptionMessage(e));
                }
                finally {
                        try {reader.close();    }
                        catch (IOException ioe) {}
                }
                return propertyTransition;
        }

        // for strings of assertion propertys: thenClause <- ifClause   
        public static AssertionProperty parseAssertionPropertyString(String inString) throws ParseException {
                Reader reader = null;
                AssertionProperty assertionProperty = null;
                try {
                        reader = new StringReader(inString) ;
                        MIDParser parser = new MIDParser(reader) ;
                        assertionProperty = parser.parseAssertionPropertyStream(inString);
            }
            catch (ParseException e) {
                throw new ParseException(LocaleBundle.bundleString("incorrect assertion")+"\u005cn"+exceptionMessage(e));
            }
                catch (TokenMgrError e){
                throw new ParseException(LocaleBundle.bundleString("incorrect assertion")+"\u005cn"+exceptionMessage(e));
                }
                finally {
                        try {reader.close();    }
                        catch (IOException ioe) {}
                }
                return assertionProperty;
        }


        // for tokens in the initial marking of visual net  
        public static ArrayList<Tuple> parseTokenString(String inString) throws ParseException {
                Reader reader = null;
                ArrayList<Tuple> tokenList = null;
                try {
                        reader = new StringReader(inString) ;
                        MIDParser parser = new MIDParser(reader) ;
                        tokenList = parser.parseTokenStream();
            }
            catch (ParseException e) {
                throw new ParseException(LocaleBundle.bundleString("incorrect token in place"));
            }
                catch (TokenMgrError e){
                throw new ParseException(LocaleBundle.bundleString("incorrect token in place"));
                }
                finally {
                        try {reader.close();    }
                        catch (IOException ioe) {}
                }
                return tokenList;
        }


        // for tokens from data files (initial states) specified in a visual net  
        public static Tuple parseTokenFromDataFile(String inString) throws ParseException {
                Reader reader = null;
                Tuple token = null;
                try {
                        reader = new StringReader(inString) ;
                        MIDParser parser = new MIDParser(reader) ;
                        token = parser.parseTokenFromDataFile();
            }
            catch (ParseException e) {
                throw new ParseException(LocaleBundle.bundleString("incorrect token in place"));
            }
                catch (TokenMgrError e){
                throw new ParseException(LocaleBundle.bundleString("incorrect token in place"));
                }
                finally {
                        try {reader.close();    }
                        catch (IOException ioe) {}
                }
                return token;
        }

        // for named integers  
        public static void parseNamedIntegersString(String inString) throws ParseException {
                Reader reader = null;
                try {
                        reader = new StringReader(inString) ;
                        MIDParser parser = new MIDParser(reader) ;
                        parser.parseNamedIntegersStream();
            }
            catch (ParseException e) {
                throw e;
            }
                catch (TokenMgrError e){
                throw e;
                }
                finally {
                        try {reader.close();    }
                        catch (IOException ioe) {}
                }
        }

        public static void parseEnumerationString(String inString) throws ParseException {
                Reader reader = null;
                try {
                        reader = new StringReader(inString) ;
                        MIDParser parser = new MIDParser(reader) ;
                        parser.parseEnumerationStream();
            }
            catch (ParseException e) {
                throw e;
            }
                catch (TokenMgrError e){
                throw e;
                }
                finally {
                        try {reader.close();    }
                        catch (IOException ioe) {}
                }
        }

        // for arc labels in a visual net  
        public static ArrayList<ArrayList<String>> parseArcLabelString(String inString) throws ParseException {
                Reader reader = null;
                ArrayList<ArrayList<String>> arcLabelList = new ArrayList<ArrayList<String>>();
                try {
                        reader = new StringReader(inString) ;
                        MIDParser parser = new MIDParser(reader) ;
                        arcLabelList = parser.parseArcLabelList();
            }
            catch (ParseException e) {
                throw new ParseException(LocaleBundle.bundleString("incorrect arc label"));
            }
                catch (TokenMgrError e){
                throw new ParseException(LocaleBundle.bundleString("incorrect arc label"));
                }
                finally {
                        try {reader.close();    }
                        catch (IOException ioe) {}
                }
                return arcLabelList;
        }

        // for object string: an object is a symbol, string or identifier
        public static boolean parseObjectString(String inString){
                Reader reader = null;
                try {
                        reader = new StringReader(inString) ;
                        MIDParser parser = new MIDParser(reader) ;
                        parser.parseObjectStream();
            }
            catch (ParseException e) {
                return false;
            }
                catch (TokenMgrError e){
                        return false;
                }
                finally {
                        try {reader.close();    }
                        catch (IOException ioe) {}
                }
                return true;
        }

        // for predicates in the mappings of methods, accessors and mutators 
        public static Predicate parseMappingPredicateString(String inString) throws ParseException {
                Reader reader = null;
                Predicate predicate = null;
                try {
                        reader = new StringReader(inString) ;
                        MIDParser parser = new MIDParser(reader) ;
                        predicate = parser.parseMappingPredicateStream();
            }
            catch (ParseException e) {
                throw new ParseException(exceptionMessage(e));
            }
                catch (TokenMgrError e){
                        throw new ParseException(exceptionMessage(e));
                }
                finally {
                        try {reader.close();    }
                        catch (IOException ioe) {}
                }
                return predicate;
        }

        // parse test parameter string, similar to condition
        // differences: 
        // (1) quotations will be removed to allow complect expressions
        //     if strings appears in paramters, use escape characters
        // (2) a test parameter (predicate) must have at least one argument.   
        public static ArrayList<Predicate> parseTestParameterString(String inString) throws ParseException {
                if (inString.equals(""))
                        return new ArrayList<Predicate>();
                Reader reader = null;
                ArrayList<Predicate> parameters = null;
                try {
                        reader = new StringReader(inString) ;
                        MIDParser parser = new MIDParser(reader) ;
                        parameters = parser.parseTestParameterStream();
            }
            catch (ParseException e) {
                throw new ParseException(inString+": "+exceptionMessage(e));
            }
                catch (TokenMgrError e){
                        throw new ParseException(inString+": "+exceptionMessage(e));
                }
                finally {
                        try {reader.close();    }
                        catch (IOException ioe) {}
                }
                return parameters;
        }

        // parse a substitution string, e.g., "[a/1, b/2]", into a substitution object
        public static Substitution parseSubstitutionString(String substitutionString) throws ParseException {
                Reader reader = null;
                Substitution substitution = null;
                try {
                        reader = new StringReader(substitutionString) ;
                        MIDParser parser = new MIDParser(reader) ;
                        substitution = parser.parseSubstitutionStream();
            }
            catch (ParseException e) {
                throw new ParseException(exceptionMessage(e));
            }
                catch (TokenMgrError e){
                        throw new ParseException(exceptionMessage(e));
                }
                finally {
                        try {reader.close();    }
                        catch (IOException ioe) {}
                }
                return substitution;

        }

        // parse a substitution string, e.g., "[a/1, b/2]", into a variable list, e.g. <a,b>
        public static ArrayList<String> parseVariablesInSubstitutionString(String substitutionString) throws ParseException {
                Reader reader = null;
                ArrayList<String> variables = null;
                try {
                        reader = new StringReader(substitutionString) ;
                        MIDParser parser = new MIDParser(reader) ;
                        variables = parser.parseVariablesInSubstitutionStream();
            }
            catch (ParseException e) {
                throw new ParseException(exceptionMessage(e));
            }
                catch (TokenMgrError e){
                        throw new ParseException(exceptionMessage(e));
                }
                finally {
                        try {reader.close();    }
                        catch (IOException ioe) {}
                }
                return variables;

        }


        // parse a string which is a list of identifiers 
        public static ArrayList<String> parseIdentifierListString(String inString) throws ParseException {
                Reader reader = null;
                ArrayList<String> list = null;
                try {
                        reader = new StringReader(inString) ;
                        MIDParser parser = new MIDParser(reader) ;
                        list = parser.parseIdentifierListStream();
            }
            catch (ParseException e) {
                throw new ParseException(exceptionMessage(e));
            }
                catch (TokenMgrError e){
                        throw new ParseException(exceptionMessage(e));
                }
                finally {
                        try {reader.close();    }
                        catch (IOException ioe) {}
                }
                return list;
        }

        public static boolean isIdentifier(String inString){
                try {
                        parseIdentifierString(inString);
                        return true;
                }
                catch (ParseException e) {
                        return false;
                }
                catch (TokenMgrError e){
                        return false;
                }
        }

        private static void parseIdentifierString(String inString) throws ParseException {
                Reader reader = null;
                try {
                        reader = new StringReader(inString) ;
                        MIDParser parser = new MIDParser(reader) ;
                        parser.parseIdentifierStream();
            }
            catch (ParseException e) {
                throw new ParseException(exceptionMessage(e));
            }
                catch (TokenMgrError e){
                        throw new ParseException(exceptionMessage(e));
                }
                finally {
                        try {reader.close();    }
                        catch (IOException ioe) {}
                }
        }

        public static ArrayList<UserDefinedSequences> parseUserDefinedTestSequences(String inString, MID mid) throws ParseException {
                Reader reader = null;
                ArrayList<UserDefinedSequences> sequences = null;
                try {
                        reader = new StringReader(inString) ;
                        MIDParser parser = new MIDParser(reader) ;
                        sequences = parser.parseUserDefinedTestSequenceStream(mid);
            }
            catch (ParseException e) {
                throw new ParseException(exceptionMessage(e));
            }
                catch (TokenMgrError e){
                        throw new ParseException(exceptionMessage(e));
                }
                finally {
                        try {reader.close();    }
                        catch (IOException ioe) {}
                }
                return sequences;
        }

        public static ArrayList<String[]> parseTestFrameworksString(String inString) throws ParseException {
                Reader reader = null;
                ArrayList<String[]> frameworks = null;
                try {
                        reader = new StringReader(inString) ;
                        MIDParser parser = new MIDParser(reader) ;
                        frameworks = parser.parseTestFrameworksStream();
            }
            catch (ParseException e) {
                throw new ParseException(exceptionMessage(e));
            }
                catch (TokenMgrError e){
                        throw new ParseException(exceptionMessage(e));
                }
                finally {
                        try {reader.close();    }
                        catch (IOException ioe) {}
                }
                return frameworks;
        }

        public static ArrayList<Predicate> parseRPCString(String inString) throws ParseException {
                Reader reader = null;
                ArrayList<Predicate> rpc = null;
                try {
                        reader = new StringReader(inString) ;
                        MIDParser parser = new MIDParser(reader) ;
                        rpc = parser.parseRpcCommaSpecification();
            }
            catch (ParseException e) {
                rpc = parseRpcColonSpecification(inString);
                if (rpc==null)
                        throw new ParseException(inString +" - "+LocaleBundle.bundleString("Incorrect RPC specification"));
            }
                catch (TokenMgrError e){
                rpc = parseRpcColonSpecification(inString);
                if (rpc==null)
                        throw new ParseException(inString +" - "+LocaleBundle.bundleString("Incorrect RPC specification"));
                }
                finally {
                        try {reader.close();    }
                        catch (IOException ioe) {}
                }
                return rpc;
        }

        private static ArrayList<Predicate> parseRpcColonSpecification(String inString) throws ParseException {
                ArrayList<Predicate> rpcs = new ArrayList<Predicate>();
                StringTokenizer lines = new StringTokenizer(inString, "\u005cn");
                while (lines.hasMoreTokens()){
                        String rpcString = lines.nextToken();
                        String methodName = null;
                        ArrayList<String> arguments = new ArrayList<String>();
                        StringTokenizer rpcStringTokenizer = new StringTokenizer(rpcString, ":");
                        while (rpcStringTokenizer.hasMoreTokens()){
                                if (methodName==null)
                                methodName = rpcStringTokenizer.nextToken().trim();
                        else
                                arguments.add(rpcStringTokenizer.nextToken().trim());
                }
                        if (!isIdentifier(methodName))
                                throw new ParseException(inString +" - "+LocaleBundle.bundleString("Incorrect RPC specification"));
                        rpcs.add(new Predicate(methodName, arguments));
                }
                return rpcs;
        }

        private static String exceptionMessage(ParseException e) {
                return e.toString().replace("parser.ParseException:", "");
        }

        private static String exceptionMessage(TokenMgrError e) {
                return e.toString().replace("parser.TokenMgrError:", "");
        }

        public static String removeQuotesFromString(String s) {
//		return s.replace('"', ' ').trim();
                if (s.charAt(0)!='"')
                        return s;
                String temp = s.substring(1, s.length()-1); // remove first and last ""
//System.out.println("New S: "+ temp.replace("\\\"", "\""));
                return temp.replace("\u005c\u005c\u005c"", "\u005c"");
        }

        private static Transition convertStateMachineTransitionToNetTransition(
                String start,
                String end,
                String event,
                String precondition,
                ArrayList<Predicate> postcondition)     {

                Transition transition = new Transition(event);
                ArrayList<Predicate> pre = new ArrayList<Predicate>();
                pre.add(new Predicate(start, new ArrayList<String>()));
                transition.setPrecondition(pre);
                ArrayList<Predicate> post = new ArrayList<Predicate>();
                post.add(new Predicate(end, new ArrayList<String>()));
                transition.setPostcondition(post);
                transition.setArguments(new ArrayList<String>());
                if (precondition!=null)
                                transition.setGuard(precondition);
                transition.setEffect(postcondition);

                transition.collectAllVariables();
                return transition;
        }

  final public ArrayList<String> TransitionArgumentSpecification() throws ParseException {
        ArrayList<String> arguments = new ArrayList<String>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
    case SPECIALVAR:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPECIALVAR:
        jj_consume_token(SPECIALVAR);
        break;
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                     arguments.add(token.toString());
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[1] = jj_gen;
          break label_1;
        }
        jj_consume_token(COMMA);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case SPECIALVAR:
          jj_consume_token(SPECIALVAR);
          break;
        case IDENTIFIER:
          jj_consume_token(IDENTIFIER);
          break;
        default:
          jj_la1[2] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                                     arguments.add(token.toString());
      }
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
                        for (String argument: arguments){
                                if (!MID.isVariable(argument))
                                        {if (true) throw new ParseException("\u005c""+argument+"\u005c" "+LocaleBundle.bundleString("is not a variable"));}
                        }
                        {if (true) return arguments;}
    throw new Error("Missing return statement in function");
  }

// for arguments in arc labels and predicates of guard conditions
  final public String GeneralArgument() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
    case SPECIALVAR:
    case SYMBOL:
    case STRING:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPECIALVAR:
        jj_consume_token(SPECIALVAR);
        break;
      case SYMBOL:
        jj_consume_token(SYMBOL);
        break;
      case STRING:
        jj_consume_token(STRING);
        break;
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                       {if (true) return token.toString();}
      break;
    case 34:
      jj_consume_token(34);
      jj_consume_token(SYMBOL);
                       {if (true) return "-"+token.toString();}
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Predicate PredicateSpecification() throws ParseException {
        String  name = "";
        ArrayList<String> arguments = new ArrayList<String>();
        String arg;
        boolean negation = false;

        String starter="";
        boolean isStarterIdentifier=false;
        boolean isPredicate=false;
        String relation="";
        String operator="";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
                negation = true;
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      jj_consume_token(IDENTIFIER);
                        starter = token.toString(); name = starter; isStarterIdentifier=true;
      break;
    case SPECIALVAR:
      jj_consume_token(SPECIALVAR);
                         starter=token.toString();
      break;
    case SYMBOL:
      jj_consume_token(SYMBOL);
                     starter=token.toString();
      break;
    case 34:
      jj_consume_token(34);
      jj_consume_token(SYMBOL);
                        starter="-"+token.toString();
      break;
    case STRING:
      jj_consume_token(STRING);
                     starter=token.toString();
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case SPECIALVAR:
      case SYMBOL:
      case STRING:
      case 34:
        arg = GeneralArgument();
                                                         arguments.add(arg);
        label_2:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[8] = jj_gen;
            break label_2;
          }
          jj_consume_token(COMMA);
          arg = GeneralArgument();
                                                         arguments.add(arg);
        }
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
                        name = starter;
                        isPredicate=true;
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LARROW:
    case RARROW:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 35:
        jj_consume_token(35);
        break;
      case 36:
        jj_consume_token(36);
        break;
      case 37:
        jj_consume_token(37);
        break;
      case RARROW:
        jj_consume_token(RARROW);
        break;
      case 38:
        jj_consume_token(38);
        break;
      case LARROW:
        jj_consume_token(LARROW);
        break;
      case 39:
        jj_consume_token(39);
        break;
      default:
        jj_la1[11] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                if (negation)
                                        {if (true) throw new ParseException(LocaleBundle.bundleString("Invalid negation")+": "+starter);}
                                if (isPredicate)
                                        {if (true) throw new ParseException(LocaleBundle.bundleString("Incorrect operator")+": "+token.toString());}
                                arguments.add(starter);
                                relation = token.toString();
                                if (relation.equals(">"))
                                        name = Functions.GreaterThan;
                                else
                                if (relation.equals(">="))
                                        name = Functions.GreaterThanOrEqualTo;
                                else
                                if (relation.equals("<"))
                                        name = Functions.LessThan;
                                else if (relation.equals("<="))
                                        name = Functions.LessThanOrEqualTo;
                                else {
                                        name = Functions.EQUALS;
                                        if (relation.equals("<>") || relation.equals("!="))
                                                negation = true;
                                }
      arg = ArithmeticExpression();
                                              arguments.add(arg);
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
                if (isPredicate && !isStarterIdentifier)
                        {if (true) throw new ParseException(LocaleBundle.bundleString("Incorrect identifier")+": "+starter);}
//System.out.println(new Predicate(name, arguments, negation));			
                {if (true) return new Predicate(name, arguments, negation);}
    throw new Error("Missing return statement in function");
  }

  final public String ArithmeticExpression() throws ParseException {
        String  expStr = "";
        String arg;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
    case SPECIALVAR:
    case SYMBOL:
    case STRING:
    case 34:
      expStr = GeneralArgument();
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
                                  expStr = "("+ ArithmeticExpression();
      jj_consume_token(RPAREN);
                                  expStr += ")";
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SLASH:
      case 34:
      case 40:
      case 41:
      case 42:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 40:
        jj_consume_token(40);
        break;
      case 34:
        jj_consume_token(34);
        break;
      case 41:
        jj_consume_token(41);
        break;
      case SLASH:
        jj_consume_token(SLASH);
        break;
      case 42:
        jj_consume_token(42);
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                       expStr += token.toString() + ArithmeticExpression();
    }
                {if (true) return expStr;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<String> collectExpressionVariables() throws ParseException {
        ArrayList<String>  variables = new ArrayList<String>();
        String arg;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
    case SPECIALVAR:
    case SYMBOL:
    case STRING:
    case 34:
      arg = GeneralArgument();
                                if (MID.isVariable(arg))
                                        variables.add(arg);
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
                                                ArrayList<String> subvars= collectExpressionVariables();
                                                for (String var: subvars)
                                                        variables.add(var);
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SLASH:
      case 34:
      case 40:
      case 41:
      case 42:
        ;
        break;
      default:
        jj_la1[17] = jj_gen;
        break label_4;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 40:
        jj_consume_token(40);
        break;
      case 34:
        jj_consume_token(34);
        break;
      case 41:
        jj_consume_token(41);
        break;
      case SLASH:
        jj_consume_token(SLASH);
        break;
      case 42:
        jj_consume_token(42);
        break;
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                ArrayList<String> subvars= collectExpressionVariables();
                                                for (String var: subvars)
                                                        variables.add(var);
    }
                {if (true) return variables;}
    throw new Error("Missing return statement in function");
  }

  final public String evaluateExpressionValue(Hashtable<String, String> bindings) throws ParseException {
        ArrayList<String>  ops = new ArrayList<String>();
        String arg;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
    case SPECIALVAR:
    case SYMBOL:
    case STRING:
    case 34:
      arg = GeneralArgument();
                                         ops.add(arg);
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
                                                ops.add(evaluateExpressionValue(bindings));
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SLASH:
      case 34:
      case 40:
      case 41:
      case 42:
        ;
        break;
      default:
        jj_la1[20] = jj_gen;
        break label_5;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 40:
        jj_consume_token(40);
        break;
      case 34:
        jj_consume_token(34);
        break;
      case 41:
        jj_consume_token(41);
        break;
      case SLASH:
        jj_consume_token(SLASH);
        break;
      case 42:
        jj_consume_token(42);
        break;
      default:
        jj_la1[21] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                ops.add(token.toString());
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case SPECIALVAR:
      case SYMBOL:
      case STRING:
      case 34:
        arg = GeneralArgument();
                                ops.add(token.toString());
        break;
      case LPAREN:
        jj_consume_token(LPAREN);
                                                ops.add(evaluateExpressionValue(bindings));
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
//for (String item: ops)
//System.out.println(item);		
                int index;
                if (ops.size()>2){
                        index=0;
                        while (index<ops.size()-2){
                                int op = Functions.getArithmeticOperator(ops.get(index+1));
                                if (op==Functions.MULTIPLICATION || op==Functions.DIVISION || op==Functions.MODULUSOP) {
                                        ops.set(index, Functions.compute(op, ops.get(index), ops.get(index+2), bindings));
                                        ops.remove(index+2);
                                        ops.remove(index+1);
                                } else {
                                        index+=2;
                                }
                        }
                }
                String result = ops.get(0);
                index = 1;
                while (index<ops.size()){
                        int op = Functions.getArithmeticOperator(ops.get(index));
                        result = Functions.compute(op, result, ops.get(index+1), bindings);
                        index+=2;
                }
                {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

// constant values (e.g., in tokens and firings) 
// IDENTIFIER can be named constants; 
  final public String ConstantArgument() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
    case SYMBOL:
    case STRING:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SYMBOL:
        jj_consume_token(SYMBOL);
        break;
      case STRING:
        jj_consume_token(STRING);
        break;
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                          {if (true) return token.toString();}
      break;
    case 34:
      jj_consume_token(34);
      jj_consume_token(SYMBOL);
                       {if (true) return "-"+token.toString();}
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void TupleSpecification(Marking marking) throws ParseException {
        String  place = null;
        ArrayList<String> arguments = new ArrayList<String>();
        String arg;
    jj_consume_token(IDENTIFIER);
                       place = token.toString();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case SYMBOL:
      case STRING:
      case 34:
        arg = ConstantArgument();
                                                  arguments.add(arg);
        label_6:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[25] = jj_gen;
            break label_6;
          }
          jj_consume_token(COMMA);
          arg = ConstantArgument();
                                                   arguments.add(arg);
        }
        break;
      default:
        jj_la1[26] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
                for (String argument: arguments)
                        if (MID.isVariable(argument)) {
                                {if (true) throw new ParseException(LocaleBundle.bundleString("init or goal state contains the following variable")+" \u005c""+argument+"\u005c".");}
                        }
                marking.addTuple(place, TupleFactory.createTuple(arguments));
  }

  final public void TokenInPlace(ArrayList<Tuple> tokenList) throws ParseException {
        ArrayList<String> arguments = new ArrayList<String>();
        String arg;
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
    case SYMBOL:
    case STRING:
    case 34:
      arg = ConstantArgument();
                                                  arguments.add(arg);
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[28] = jj_gen;
          break label_7;
        }
        jj_consume_token(COMMA);
        arg = ConstantArgument();
                                                   arguments.add(arg);
      }
      break;
    default:
      jj_la1[29] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
                for (String argument: arguments)
                        if (MID.isVariable(argument)) {
                                {if (true) throw new ParseException(LocaleBundle.bundleString("init or goal state contains the following variable")+" \u005c""+argument+"\u005c".");}
                        }
                tokenList.add(TupleFactory.createTuple(arguments));
  }

  final private Tuple parseTokenFromDataFile() throws ParseException {
        ArrayList<String> arguments = new ArrayList<String>();
        String arg;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case SYMBOL:
      case STRING:
      case 34:
        arg = ConstantArgument();
                                                   arguments.add(arg);
        label_8:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[30] = jj_gen;
            break label_8;
          }
          jj_consume_token(COMMA);
          arg = ConstantArgument();
                                                    arguments.add(arg);
        }
        break;
      default:
        jj_la1[31] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
      break;
    case IDENTIFIER:
    case SYMBOL:
    case STRING:
    case 34:
      arg = ConstantArgument();
                                           arguments.add(arg);
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[32] = jj_gen;
          break label_9;
        }
        jj_consume_token(COMMA);
        arg = ConstantArgument();
                                            arguments.add(arg);
      }
      break;
    default:
      jj_la1[33] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                for (String argument: arguments){
                        if (MID.isVariable(argument)) {
                                {if (true) throw new ParseException(LocaleBundle.bundleString("init or goal state contains the following variable")+" \u005c""+argument+"\u005c".");}
                        }
                }
                {if (true) return TupleFactory.createTuple(arguments);}
    throw new Error("Missing return statement in function");
  }

  final private ArrayList<ArrayList<String>> parseArcLabelList() throws ParseException {
        ArrayList<String> arcLabel;
        ArrayList<ArrayList<String>> arcLabelList = new ArrayList<ArrayList<String>>();
    arcLabel = ArcLabel();
                                  arcLabelList.add(arcLabel);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 43:
        ;
        break;
      default:
        jj_la1[34] = jj_gen;
        break label_10;
      }
      jj_consume_token(43);
              arcLabelList.add(ArcLabel());
    }
    jj_consume_token(0);
                if (arcLabelList.size()>1){
                        int argCount = arcLabelList.get(0).size();
                        for (int i=1; i<arcLabelList.size(); i++)
                                if (arcLabelList.get(i).size()!=argCount)
                                        {if (true) throw new ParseException(LocaleBundle.bundleString("Incorrect multiple labels"));}
                }
                {if (true) return arcLabelList;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<String> ArcLabel() throws ParseException {
        ArrayList<String> arguments = new ArrayList<String>();
        String arg;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
    case SPECIALVAR:
    case SYMBOL:
    case STRING:
    case LARROW:
    case 34:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LARROW:
        jj_consume_token(LARROW);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
        case SPECIALVAR:
        case SYMBOL:
        case STRING:
        case 34:
          arg = GeneralArgument();
                                                 arguments.add(arg);
          label_11:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case COMMA:
              ;
              break;
            default:
              jj_la1[35] = jj_gen;
              break label_11;
            }
            jj_consume_token(COMMA);
            arg = GeneralArgument();
                                                  arguments.add(arg);
          }
          break;
        default:
          jj_la1[36] = jj_gen;
          ;
        }
        jj_consume_token(RARROW);
        break;
      case IDENTIFIER:
      case SPECIALVAR:
      case SYMBOL:
      case STRING:
      case 34:
        arg = GeneralArgument();
                                                 arguments.add(arg);
        label_12:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[37] = jj_gen;
            break label_12;
          }
          jj_consume_token(COMMA);
          arg = GeneralArgument();
                                                  arguments.add(arg);
        }
        break;
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[39] = jj_gen;
      ;
    }
                {if (true) return arguments;}
    throw new Error("Missing return statement in function");
  }

  final private ArrayList<Predicate> parseConditionStream() throws ParseException {
        Predicate predicate;
        ArrayList<Predicate> condition = new ArrayList<Predicate>();
    predicate = PredicateSpecification();
                                                 condition.add(predicate);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[40] = jj_gen;
        break label_13;
      }
      jj_consume_token(COMMA);
                  condition.add(PredicateSpecification());
    }
    jj_consume_token(0);
                {if (true) return condition;}
    throw new Error("Missing return statement in function");
  }

  final private Predicate parseTransitionSignatureStream() throws ParseException {
        String name;
        ArrayList<String> arguments = null;
    jj_consume_token(IDENTIFIER);
                       name = token.toString();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
                          arguments = TransitionArgumentSpecification();
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[41] = jj_gen;
      ;
    }
    jj_consume_token(0);
                {if (true) return new Predicate(name, arguments);}
    throw new Error("Missing return statement in function");
  }

  final private GoalProperty parseGoalPropertyStream(String propertyString) throws ParseException {
        Predicate predicate;
        String propertyName = MID.DEFAULT_GOAL_TAG;
        ArrayList<Predicate> condition = new ArrayList<Predicate>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
      jj_consume_token(LBRACKET);
      jj_consume_token(IDENTIFIER);
                              propertyName=token.toString();
      jj_consume_token(RBRACKET);
      break;
    default:
      jj_la1[42] = jj_gen;
      ;
    }
    predicate = PredicateSpecification();
                                                 condition.add(predicate);
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[43] = jj_gen;
        break label_14;
      }
      jj_consume_token(COMMA);
                  condition.add(PredicateSpecification());
    }
    jj_consume_token(0);
                GoalProperty propertyTransition = new GoalProperty(propertyName, propertyString);
                propertyTransition.setPrecondition(condition);
                propertyTransition.transformFromContract();
                propertyTransition.collectAllVariables();
                {if (true) return propertyTransition;}
    throw new Error("Missing return statement in function");
  }

  final private AssertionProperty parseAssertionPropertyStream(String assertionString) throws ParseException {
        String assertionName = "";
        Predicate ifPredicate;
        ArrayList<Predicate> ifCondition = new ArrayList<Predicate>();
        Predicate thenPredicate;
        ArrayList<Predicate> thenCondition = new ArrayList<Predicate>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
      jj_consume_token(LBRACKET);
      jj_consume_token(IDENTIFIER);
                              assertionName=token.toString();
      jj_consume_token(RBRACKET);
      break;
    default:
      jj_la1[44] = jj_gen;
      ;
    }
    ifPredicate = PredicateSpecification();
                                                   ifCondition.add(ifPredicate);
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[45] = jj_gen;
        break label_15;
      }
      jj_consume_token(COMMA);
                  ifCondition.add(PredicateSpecification());
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 44:
    case 45:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 44:
        jj_consume_token(44);
        break;
      case 45:
        jj_consume_token(45);
        break;
      default:
        jj_la1[46] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      thenPredicate = PredicateSpecification();
                                                     thenCondition.add(thenPredicate);
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[47] = jj_gen;
          break label_16;
        }
        jj_consume_token(COMMA);
                  thenCondition.add(PredicateSpecification());
      }
      break;
    default:
      jj_la1[48] = jj_gen;
      ;
    }
    jj_consume_token(0);
                Transition ifClause = new Transition(assertionName);
                ifClause.setPrecondition(ifCondition);
                ifClause.transformFromContract();
                ifClause.collectAllVariables();

                Transition thenClause = new Transition(assertionName);
                thenClause.setPrecondition(thenCondition);
                thenClause.transformFromContract();
                thenClause.collectAllVariables();

                if (thenCondition.size()>0)
                        {if (true) return new AssertionProperty(assertionString, assertionName, ifClause, thenClause);}
                else
                        {if (true) return new AssertionProperty(assertionString, assertionName, thenClause, ifClause);}
    throw new Error("Missing return statement in function");
  }

  final private Marking parseMarkingStream() throws ParseException {
        Marking marking = new Marking();
    TupleSpecification(marking);
    label_17:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[49] = jj_gen;
        break label_17;
      }
      jj_consume_token(COMMA);
                  TupleSpecification(marking);
    }
    jj_consume_token(0);
                {if (true) return marking;}
    throw new Error("Missing return statement in function");
  }

  final private ArrayList<Tuple> parseTokenStream() throws ParseException {
        ArrayList<Tuple> tokenList = new ArrayList<Tuple>();
    TokenInPlace(tokenList);
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[50] = jj_gen;
        break label_18;
      }
      jj_consume_token(COMMA);
                  TokenInPlace(tokenList);
    }
    jj_consume_token(0);
                {if (true) return tokenList;}
    throw new Error("Missing return statement in function");
  }

  final private void parseNamedIntegersStream() throws ParseException {
        String symbol="";
        String value="";
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[51] = jj_gen;
        break label_19;
      }
      jj_consume_token(IDENTIFIER);
                      symbol=token.toString();
                                if (symbol.length()==0)
                                        {if (true) throw new ParseException(LocaleBundle.bundleString("Incorrect constant name")+" :"+symbol);}
                                if (!Character.isUpperCase(symbol.charAt(0)))
                                        {if (true) throw new ParseException(LocaleBundle.bundleString("Incorrect constant name")+" :"+symbol);}
                                value = "";
      jj_consume_token(35);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 34:
        jj_consume_token(34);
                       value=token.toString();
        break;
      default:
        jj_la1[52] = jj_gen;
        ;
      }
      jj_consume_token(SYMBOL);
                  value += token.toString();
                                try {
                                        Integer.parseInt(value);
                                }
                                catch (Exception e) {
                                        {if (true) throw new ParseException(LocaleBundle.bundleString("Incorrect constant value")+" :"+value);}
                                }
                                MID.putSymbolNumber(symbol, value);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
      case COMMA:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          jj_consume_token(COMMA);
          break;
        case SEMICOLON:
          jj_consume_token(SEMICOLON);
          break;
        default:
          jj_la1[53] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[54] = jj_gen;
        ;
      }
    }
    jj_consume_token(0);
  }

  final private void parseEnumerationStream() throws ParseException {
        int index=0;
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[55] = jj_gen;
        break label_20;
      }
      jj_consume_token(IDENTIFIER);
                        String symbol=token.toString();
                                if (symbol.length()==0)
                                        {if (true) throw new ParseException(LocaleBundle.bundleString("Incorrect constant name")+" :"+symbol);}
                                if (!Character.isUpperCase(symbol.charAt(0)))
                                        {if (true) throw new ParseException(LocaleBundle.bundleString("Incorrect constant name")+" :"+symbol);}
                                MID.putSymbolNumber(symbol, Integer.toString(index));
                                index++;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMICOLON:
      case COMMA:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          jj_consume_token(COMMA);
          break;
        case SEMICOLON:
          jj_consume_token(SEMICOLON);
          break;
        default:
          jj_la1[56] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[57] = jj_gen;
        ;
      }
    }
    jj_consume_token(0);
  }

  final private Predicate parseMappingPredicateStream() throws ParseException {
        Predicate predicate;
    predicate = PredicateSpecification();
    jj_consume_token(0);
                {if (true) return predicate;}
    throw new Error("Missing return statement in function");
  }

  final private Substitution parseSubstitutionStream() throws ParseException {
        Hashtable<String, String> bindings = new Hashtable <String, String>();
        String variable;
        String value;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
      jj_consume_token(LBRACKET);
      break;
    default:
      jj_la1[58] = jj_gen;
      ;
    }
    label_21:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case SPECIALVAR:
        ;
        break;
      default:
        jj_la1[59] = jj_gen;
        break label_21;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      case SPECIALVAR:
        jj_consume_token(SPECIALVAR);
        break;
      default:
        jj_la1[60] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                              variable = token.toString();
      jj_consume_token(SLASH);
      value = ConstantArgument();
                                            bindings.put(variable, value);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[61] = jj_gen;
        ;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RBRACKET:
      jj_consume_token(RBRACKET);
      break;
    default:
      jj_la1[62] = jj_gen;
      ;
    }
    jj_consume_token(0);
                {if (true) return new Substitution(bindings);}
    throw new Error("Missing return statement in function");
  }

  final private ArrayList<String> parseVariablesInSubstitutionStream() throws ParseException {
        ArrayList<String> variables = new ArrayList<String>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
      jj_consume_token(LBRACKET);
      break;
    default:
      jj_la1[63] = jj_gen;
      ;
    }
    label_22:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case SPECIALVAR:
        ;
        break;
      default:
        jj_la1[64] = jj_gen;
        break label_22;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      case SPECIALVAR:
        jj_consume_token(SPECIALVAR);
        break;
      default:
        jj_la1[65] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                             variables.add(token.toString());
      jj_consume_token(SLASH);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRING:
        jj_consume_token(STRING);
        break;
      case SYMBOL:
        jj_consume_token(SYMBOL);
        break;
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      case 34:
        jj_consume_token(34);
        jj_consume_token(SYMBOL);
        break;
      default:
        jj_la1[66] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[67] = jj_gen;
        ;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RBRACKET:
      jj_consume_token(RBRACKET);
      break;
    default:
      jj_la1[68] = jj_gen;
      ;
    }
    jj_consume_token(0);
                {if (true) return variables;}
    throw new Error("Missing return statement in function");
  }

  final private ArrayList<String> parseIdentifierListStream() throws ParseException {
        ArrayList<String> list = new ArrayList<String>();
    jj_consume_token(IDENTIFIER);
                       list.add(token.toString());
    label_23:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[69] = jj_gen;
        break label_23;
      }
      jj_consume_token(COMMA);
      jj_consume_token(IDENTIFIER);
                               list.add(token.toString());
    }
    jj_consume_token(0);
                {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  final private void parseIdentifierStream() throws ParseException {
    jj_consume_token(IDENTIFIER);
    jj_consume_token(0);
  }

  final private void parseObjectStream() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      jj_consume_token(IDENTIFIER);
      break;
    case STRING:
      jj_consume_token(STRING);
      break;
    case SYMBOL:
      jj_consume_token(SYMBOL);
      break;
    case 34:
      jj_consume_token(34);
      jj_consume_token(SYMBOL);
      break;
    default:
      jj_la1[70] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                if (MID.isVariable(token.toString()))
                        {if (true) throw new ParseException(LocaleBundle.bundleString("Object spec contains the following variable")+token.toString());}
    jj_consume_token(0);
  }

  final private ArrayList<Predicate> parseTestParameterStream() throws ParseException {
        ArrayList<Predicate> tests = new ArrayList<Predicate>();
        Predicate predicate = null;
    predicate = parseOneTestParameter();
                                               tests.add(predicate);
    label_24:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[71] = jj_gen;
        break label_24;
      }
      jj_consume_token(COMMA);
      predicate = parseOneTestParameter();
                                                       tests.add(predicate);
    }
    jj_consume_token(0);
                {if (true) return tests;}
    throw new Error("Missing return statement in function");
  }

  final private Predicate parseOneTestParameter() throws ParseException {
        String event = null;
        ArrayList<String> arguments = new ArrayList<String>();
        String arg;
    jj_consume_token(IDENTIFIER);
                               event = token.toString();
    jj_consume_token(LPAREN);
    arg = ConstantArgument();
                                          arguments.add(removeQuotesFromString(arg));
    label_25:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[72] = jj_gen;
        break label_25;
      }
      jj_consume_token(COMMA);
      arg = ConstantArgument();
                                                  arguments.add(removeQuotesFromString(arg));
    }
    jj_consume_token(RPAREN);
                        {if (true) return new Predicate(event, arguments);}
    throw new Error("Missing return statement in function");
  }

  final private ArrayList<UserDefinedSequences> parseUserDefinedTestSequenceStream(MID mid) throws ParseException {
        ArrayList<UserDefinedSequences> allSequences = UserDefinedSequences.initializeALLSequences(mid);
        int initMarkingIndex = 0;
    label_26:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEQUENCE:
        ;
        break;
      default:
        jj_la1[73] = jj_gen;
        break label_26;
      }
      jj_consume_token(SEQUENCE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        jj_consume_token(INIT);
        jj_consume_token(SYMBOL);
                                try {
                                        initMarkingIndex = Integer.parseInt(token.toString());
                                } catch (Exception e) {
                                        {if (true) throw new ParseException(mid.getSequencesFile()+ ": Encountered "+ token.toString()+": expecting non-negative number.");}
                                }
                                if (initMarkingIndex<0 || initMarkingIndex>mid.getInitialMarkings().size())
                                        {if (true) throw new ParseException(mid.getSequencesFile()+ ": Incorrect initial state index: "+ token.toString());}
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[74] = jj_gen;
        ;
      }
                ArrayList<Firing> firings = parseFiringList(mid);
                allSequences.get(initMarkingIndex).addSequence(new FiringSequence(firings));
    }
    jj_consume_token(0);
                {if (true) return allSequences;}
    throw new Error("Missing return statement in function");
  }

  final private ArrayList<Firing> parseFiringList(MID mid) throws ParseException {
        ArrayList<Firing> firings = new ArrayList<Firing>();
        Firing firing;
    label_27:
    while (true) {
      firing = parseFiring(mid);
                                      firings.add(firing);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[75] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[76] = jj_gen;
        break label_27;
      }
    }
                {if (true) return firings;}
    throw new Error("Missing return statement in function");
  }

  final private Firing parseFiring(MID mid) throws ParseException {
        Transition transition;
        Hashtable<String, String> bindings = new Hashtable <String, String>();
        String variable;
        String arg;
    transition = parseTransitionInSequence(mid);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
      jj_consume_token(LBRACKET);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      case SPECIALVAR:
        jj_consume_token(SPECIALVAR);
        break;
      default:
        jj_la1[77] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                              variable = token.toString();
                                                                        if (!transition.hasVariable(variable))
                                                                                {if (true) throw new ParseException(mid.getSequencesFile()+ ": variable "+ variable +" not found for the transition.");}
      jj_consume_token(SLASH);
      arg = ConstantArgument();
                                          bindings.put(variable, arg);
      label_28:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[78] = jj_gen;
          break label_28;
        }
        jj_consume_token(COMMA);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          jj_consume_token(IDENTIFIER);
          break;
        case SPECIALVAR:
          jj_consume_token(SPECIALVAR);
          break;
        default:
          jj_la1[79] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                                      variable = token.toString();
                                                                        if (!transition.hasVariable(variable))
                                                                                {if (true) throw new ParseException(mid.getSequencesFile()+ ": variable "+ variable +" not found for the transition.");}
        jj_consume_token(SLASH);
        arg = ConstantArgument();
                                                  bindings.put(variable, arg);
      }
      jj_consume_token(RBRACKET);
      break;
    default:
      jj_la1[80] = jj_gen;
      ;
    }
                ArrayList<String> arguments = transition.getArguments();
                if (arguments==null)
                        arguments = transition.getAllVariables();
                if (arguments!=null){
                        for (String argument: arguments)
                                if (!bindings.containsKey(argument))
                                        {if (true) throw new ParseException(mid.getSequencesFile()+ ": Argument "+ argument +" is not bound in "
                                                                        +transition.getEvent()+" "+new Substitution(bindings).printAllBindings() +" for the following transition\u005cn"+transition);}
                }
                {if (true) return new Firing(transition, new Substitution(bindings));}
    throw new Error("Missing return statement in function");
  }

  final private Transition parseTransitionInSequence(MID mid) throws ParseException {
        String event = "";
        int transitionIndex = -1;
        Transition transition = null;
    jj_consume_token(IDENTIFIER);
                       event = token.toString();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SYMBOL:
      jj_consume_token(SYMBOL);
                                try {
                                        transitionIndex = Integer.parseInt(token.toString());
                                } catch (Exception e) {
                                        {if (true) throw new ParseException(mid.getSequencesFile()+ ": "+ token.toString()+": expecting non-negative number.");}
                                }
                                if (transitionIndex<0 || transitionIndex > mid.getTransitions().size())
                                        {if (true) throw new ParseException(mid.getSequencesFile()+ ": Incorrect transition index: "+ token.toString()+".");}
                                transition = mid.getTransitionAtIndex(transitionIndex);
      break;
    default:
      jj_la1[81] = jj_gen;
      ;
    }
                if (transition==null){
                        ArrayList<Transition> transitions = mid.getTransitionsForEvent(event);
                        if (transitions!=null && transitions.size()>0)
                                transition = transitions.get(0);
                        else
                                {if (true) throw new ParseException(mid.getSequencesFile()+ ": Transition: "+ event +" not defined.");}
                }
                {if (true) return transition;}
    throw new Error("Missing return statement in function");
  }

  final private ArrayList<String[]> parseTestFrameworksStream() throws ParseException {
        ArrayList<String[]> testFrameworks = new ArrayList<String[]>();
        String[] frameworkSpec;
    label_29:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TEST:
        ;
        break;
      default:
        jj_la1[82] = jj_gen;
        break label_29;
      }
      jj_consume_token(TEST);
      jj_consume_token(FRAMEWORK);
      jj_consume_token(STRING);
                  frameworkSpec = new String[4];
                          frameworkSpec[0] = removeQuotesFromString(token.toString());
      jj_consume_token(COMMA);
      jj_consume_token(STRING);
                  frameworkSpec[1] = removeQuotesFromString(token.toString());
      jj_consume_token(COMMA);
      jj_consume_token(STRING);
                  frameworkSpec[2] = removeQuotesFromString(token.toString()).replaceAll(";", ";\u005cn");
      jj_consume_token(COMMA);
      jj_consume_token(STRING);
                  frameworkSpec[3] = removeQuotesFromString(token.toString());
                        testFrameworks.add(frameworkSpec);
    }
    jj_consume_token(0);
                {if (true) return testFrameworks;}
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<Predicate> parseRpcCommaSpecification() throws ParseException {
        ArrayList<Predicate> rpcs = new ArrayList<Predicate>();
        String  methodName = null;
        ArrayList<String> arguments = null;
        String arg;
    label_30:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[83] = jj_gen;
        break label_30;
      }
      jj_consume_token(IDENTIFIER);
                        methodName = token.toString(); arguments= new ArrayList<String>(); arg="";
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LPAREN:
        jj_consume_token(LPAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
        case SYMBOL:
        case STRING:
        case 34:
          arg = ConstantArgument();
                                                  arguments.add(arg);
          label_31:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case COMMA:
              ;
              break;
            default:
              jj_la1[84] = jj_gen;
              break label_31;
            }
            jj_consume_token(COMMA);
            arg = ConstantArgument();
                                                  arguments.add(arg);
          }
          break;
        default:
          jj_la1[85] = jj_gen;
          ;
        }
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[86] = jj_gen;
        ;
      }
                        rpcs.add(new Predicate(methodName, arguments));
    }
    jj_consume_token(0);
                {if (true) return rpcs;}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public MIDParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[87];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xc000,0x80000000,0xc000,0xc000,0x9c000,0x9c000,0x200,0x9c000,0x80000000,0x9c000,0x100000,0xc00000,0xc00000,0x19c000,0x0,0x0,0x19c000,0x0,0x0,0x19c000,0x0,0x0,0x19c000,0x94000,0x94000,0x80000000,0x94000,0x100000,0x80000000,0x94000,0x80000000,0x94000,0x80000000,0x194000,0x0,0x80000000,0x9c000,0x80000000,0x49c000,0x49c000,0x80000000,0x100000,0x4000000,0x80000000,0x4000000,0x80000000,0x0,0x80000000,0x0,0x80000000,0x80000000,0x4000,0x0,0x90000000,0x90000000,0x4000,0x90000000,0x90000000,0x4000000,0xc000,0xc000,0x80000000,0x8000000,0x4000000,0xc000,0xc000,0x94000,0x80000000,0x8000000,0x80000000,0x94000,0x80000000,0x80000000,0x400,0x100000,0x80000000,0x4000,0xc000,0x80000000,0xc000,0x4000000,0x10000,0x1000,0x4000,0x80000000,0x94000,0x100000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x4,0x0,0x4,0x0,0xf8,0xf8,0x4,0x706,0x706,0x4,0x706,0x706,0x4,0x706,0x706,0x4,0x0,0x4,0x0,0x4,0x0,0x0,0x4,0x0,0x4,0x0,0x4,0x800,0x0,0x4,0x0,0x4,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x3000,0x0,0x3000,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,};
   }

  /** Constructor with InputStream. */
  public MIDParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public MIDParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new MIDParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 87; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 87; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public MIDParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new MIDParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 87; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 87; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public MIDParser(MIDParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 87; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(MIDParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 87; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[46];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 87; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 46; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
